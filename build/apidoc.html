<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://howlerjs.com"

    >howler (v2.0.3)</a>
</h1>
<h4>Javascript audio library for the modern web.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.howler">module howler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.howler.Howl">
            function <span class="apidocSignatureSpan">howler.</span>Howl
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">howler.</span>Howl.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">howler.</span>Howler</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.howler.Howl">module howler.Howl</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.howler.Howl.Howl">
            function <span class="apidocSignatureSpan">howler.</span>Howl
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.howler.Howl.prototype">module howler.Howl.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.howler.Howl.prototype._cleanBuffer">
            function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>_cleanBuffer
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.howler.Howl.prototype._clearTimer">
            function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>_clearTimer
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.howler.Howl.prototype._drain">
            function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>_drain
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.howler.Howl.prototype._emit">
            function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>_emit
            <span class="apidocSignatureSpan">(event, id, msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.howler.Howl.prototype._ended">
            function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>_ended
            <span class="apidocSignatureSpan">(sound)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.howler.Howl.prototype._getSoundIds">
            function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>_getSoundIds
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.howler.Howl.prototype._inactiveSound">
            function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>_inactiveSound
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.howler.Howl.prototype._loadQueue">
            function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>_loadQueue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.howler.Howl.prototype._refreshBuffer">
            function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>_refreshBuffer
            <span class="apidocSignatureSpan">(sound)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.howler.Howl.prototype._soundById">
            function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>_soundById
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.howler.Howl.prototype._stopFade">
            function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>_stopFade
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.howler.Howl.prototype.duration">
            function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>duration
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.howler.Howl.prototype.fade">
            function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>fade
            <span class="apidocSignatureSpan">(from, to, len, id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.howler.Howl.prototype.init">
            function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>init
            <span class="apidocSignatureSpan">(o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.howler.Howl.prototype.load">
            function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>load
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.howler.Howl.prototype.loop">
            function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>loop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.howler.Howl.prototype.mute">
            function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>mute
            <span class="apidocSignatureSpan">(muted, id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.howler.Howl.prototype.off">
            function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>off
            <span class="apidocSignatureSpan">(event, fn, id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.howler.Howl.prototype.on">
            function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>on
            <span class="apidocSignatureSpan">(event, fn, id, once)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.howler.Howl.prototype.once">
            function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>once
            <span class="apidocSignatureSpan">(event, fn, id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.howler.Howl.prototype.orientation">
            function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>orientation
            <span class="apidocSignatureSpan">(x, y, z, id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.howler.Howl.prototype.pannerAttr">
            function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>pannerAttr
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.howler.Howl.prototype.pause">
            function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>pause
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.howler.Howl.prototype.play">
            function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>play
            <span class="apidocSignatureSpan">(sprite, internal)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.howler.Howl.prototype.playing">
            function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>playing
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.howler.Howl.prototype.pos">
            function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>pos
            <span class="apidocSignatureSpan">(x, y, z, id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.howler.Howl.prototype.rate">
            function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>rate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.howler.Howl.prototype.seek">
            function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>seek
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.howler.Howl.prototype.state">
            function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>state
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.howler.Howl.prototype.stereo">
            function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>stereo
            <span class="apidocSignatureSpan">(pan, id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.howler.Howl.prototype.stop">
            function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>stop
            <span class="apidocSignatureSpan">(id, internal)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.howler.Howl.prototype.unload">
            function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>unload
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.howler.Howl.prototype.volume">
            function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>volume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.howler" id="apidoc.module.howler">module howler</a></h1>


    <h2>
        <a href="#apidoc.element.howler.Howl" id="apidoc.element.howler.Howl">
        function <span class="apidocSignatureSpan">howler.</span>Howl
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Howl = function (o) {
  var self = this;

  // Throw an error if no source is provided.
  if (!o.src || o.src.length === 0) {
    console.error(&#x27;An array of source files must be passed with any new Howl.&#x27;);
    return;
  }

  self.init(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.howler.Howl" id="apidoc.module.howler.Howl">module howler.Howl</a></h1>


    <h2>
        <a href="#apidoc.element.howler.Howl.Howl" id="apidoc.element.howler.Howl.Howl">
        function <span class="apidocSignatureSpan">howler.</span>Howl
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Howl = function (o) {
  var self = this;

  // Throw an error if no source is provided.
  if (!o.src || o.src.length === 0) {
    console.error(&#x27;An array of source files must be passed with any new Howl.&#x27;);
    return;
  }

  self.init(o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.howler.Howl.prototype" id="apidoc.module.howler.Howl.prototype">module howler.Howl.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.howler.Howl.prototype._cleanBuffer" id="apidoc.element.howler.Howl.prototype._cleanBuffer">
        function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>_cleanBuffer
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_cleanBuffer = function (node) {
  var self = this;

  if (self._scratchBuffer) {
    node.bufferSource.onended = null;
    node.bufferSource.disconnect(0);
    try { node.bufferSource.buffer = self._scratchBuffer; } catch(e) {}
  }
  node.bufferSource = null;

  return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      if (typeof sound._node.bufferSource.stop === &#x27;undefined&#x27;) {
        sound._node.bufferSource.noteOff(0);
      } else {
        sound._node.bufferSource.stop(0);
      }

      // Clean up the buffer source.
      self.<span class="apidocCodeKeywordSpan">_cleanBuffer</span>(sound._node);
    } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
      sound._node.pause();
    }
  }
}

// Fire the pause event, unless `true` is passed as the 2nd argument.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.howler.Howl.prototype._clearTimer" id="apidoc.element.howler.Howl.prototype._clearTimer">
        function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>_clearTimer
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_clearTimer = function (id) {
  var self = this;

  if (self._endTimers[id]) {
    clearTimeout(self._endTimers[id]);
    delete self._endTimers[id];
  }

  return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    playWebAudio();
  } else {
    // Wait for the audio to load and then begin playback.
    var event = !isRunning &#x26;&#x26; self._state === &#x27;loaded&#x27; ? &#x27;resume&#x27; : &#x27;load&#x27;;
    self.once(event, playWebAudio, isRunning ? sound._id : null);

    // Cancel the end timer.
    self.<span class="apidocCodeKeywordSpan">_clearTimer</span>(sound._id);
  }
} else {
  // Fire this when the sound is ready to play to begin HTML5 Audio playback.
  var playHtml5 = function() {
    node.currentTime = seek;
    node.muted = sound._muted || self._muted || Howler._muted || node.muted;
    node.volume = sound._volume * Howler.volume();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.howler.Howl.prototype._drain" id="apidoc.element.howler.Howl.prototype._drain">
        function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>_drain
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_drain = function () {
  var self = this;
  var limit = self._pool;
  var cnt = 0;
  var i = 0;

  // If there are less sounds than the max pool size, we are done.
  if (self._sounds.length &#x3c; limit) {
    return;
  }

  // Count the number of inactive sounds.
  for (i=0; i&#x3c;self._sounds.length; i++) {
    if (self._sounds[i]._ended) {
      cnt++;
    }
  }

  // Remove excess inactive sounds, going in reverse order.
  for (i=self._sounds.length - 1; i&#x3e;=0; i--) {
    if (cnt &#x3c;= limit) {
      return;
    }

    if (self._sounds[i]._ended) {
      // Disconnect the audio source when using Web Audio.
      if (self._webAudio &#x26;&#x26; self._sounds[i]._node) {
        self._sounds[i]._node.disconnect(0);
      }

      // Remove sounds until we have the pool size.
      self._sounds.splice(i, 1);
      cnt--;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    /**
     * Return an inactive sound from the pool or create a new one.
     * @return {Sound} Sound playback object.
     */
    _inactiveSound: function() {
var self = this;

self.<span class="apidocCodeKeywordSpan">_drain</span>();

// Find the first inactive node to recycle.
for (var i=0; i&#x3c;self._sounds.length; i++) {
  if (self._sounds[i]._ended) {
    return self._sounds[i].reset();
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.howler.Howl.prototype._emit" id="apidoc.element.howler.Howl.prototype._emit">
        function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>_emit
        <span class="apidocSignatureSpan">(event, id, msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_emit = function (event, id, msg) {
  var self = this;
  var events = self[&#x27;_on&#x27; + event];

  // Loop through event store and fire all functions.
  for (var i=events.length-1; i&#x3e;=0; i--) {
    if (!events[i].id || events[i].id === id || event === &#x27;load&#x27;) {
      setTimeout(function(fn) {
        fn.call(this, id, msg);
      }.bind(self, events[i].fn), 0);

      // If this event was setup with `once`, remove it.
      if (events[i].once) {
        self.off(event, events[i].fn, events[i].id);
      }
    }
  }

  return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      } else if (self.state === &#x27;suspended&#x27;) {
self.state = &#x27;resuming&#x27;;
self.ctx.resume().then(function() {
  self.state = &#x27;running&#x27;;

  // Emit to all Howls that the audio has resumed.
  for (var i=0; i&#x3c;self._howls.length; i++) {
    self._howls[i].<span class="apidocCodeKeywordSpan">_emit</span>(&#x27;resume&#x27;);
  }
});

if (self._suspendTimer) {
  clearTimeout(self._suspendTimer);
  self._suspendTimer = null;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.howler.Howl.prototype._ended" id="apidoc.element.howler.Howl.prototype._ended">
        function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>_ended
        <span class="apidocSignatureSpan">(sound)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_ended = function (sound) {
  var self = this;
  var sprite = sound._sprite;

  // Should this sound loop?
  var loop = !!(sound._loop || self._sprite[sprite][2]);

  // Fire the ended event.
  self._emit(&#x27;end&#x27;, sound._id);

  // Restart the playback for HTML5 Audio loop.
  if (!self._webAudio &#x26;&#x26; loop) {
    self.stop(sound._id, true).play(sound._id);
  }

  // Restart this timer if on a Web Audio loop.
  if (self._webAudio &#x26;&#x26; loop) {
    self._emit(&#x27;play&#x27;, sound._id);
    sound._seek = sound._start || 0;
    sound._rateSeek = 0;
    sound._playStart = Howler.ctx.currentTime;

    var timeout = ((sound._stop - sound._start) * 1000) / Math.abs(sound._rate);
    self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
  }

  // Mark the node as paused.
  if (self._webAudio &#x26;&#x26; !loop) {
    sound._paused = true;
    sound._ended = true;
    sound._seek = sound._start || 0;
    sound._rateSeek = 0;
    self._clearTimer(sound._id);

    // Clean up the buffer source.
    self._cleanBuffer(sound._node);

    // Attempt to auto-suspend AudioContext if no sounds are still playing.
    Howler._autoSuspend();
  }

  // When using a sprite, end the track.
  if (!self._webAudio &#x26;&#x26; !loop) {
    self.stop(sound._id);
  }

  return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.howler.Howl.prototype._getSoundIds" id="apidoc.element.howler.Howl.prototype._getSoundIds">
        function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>_getSoundIds
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getSoundIds = function (id) {
  var self = this;

  if (typeof id === &#x27;undefined&#x27;) {
    var ids = [];
    for (var i=0; i&#x3c;self._sounds.length; i++) {
      ids.push(self._sounds[i]._id);
    }

    return ids;
  } else {
    return [id];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          self.masterGain.gain.value = vol;
        }

        // Loop through and change volume for all HTML5 audio nodes.
        for (var i=0; i&#x3c;self._howls.length; i++) {
          if (!self._howls[i]._webAudio) {
            // Get all of the sounds in this Howl group.
            var ids = self._howls[i].<span class="apidocCodeKeywordSpan">_getSoundIds</span>();

            // Loop through all sounds and change the volumes.
            for (var j=0; j&#x3c;ids.length; j++) {
var sound = self._howls[i]._soundById(ids[j]);

if (sound &#x26;&#x26; sound._node) {
  sound._node.volume = sound._volume * vol;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.howler.Howl.prototype._inactiveSound" id="apidoc.element.howler.Howl.prototype._inactiveSound">
        function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>_inactiveSound
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_inactiveSound = function () {
  var self = this;

  self._drain();

  // Find the first inactive node to recycle.
  for (var i=0; i&#x3c;self._sounds.length; i++) {
    if (self._sounds[i]._ended) {
      return self._sounds[i].reset();
    }
  }

  // If no inactive node was found, create a new one.
  return new Sound(self);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    sprite = null;
  } else {
    id = null;
  }
}

// Get the selected node, or get one from the pool.
var sound = id ? self._soundById(id) : self.<span class="apidocCodeKeywordSpan">_inactiveSound</span>();

// If the sound doesn&#x27;t exist, do nothing.
if (!sound) {
  return null;
}

// Select the sprite definition.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.howler.Howl.prototype._loadQueue" id="apidoc.element.howler.Howl.prototype._loadQueue">
        function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>_loadQueue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_loadQueue = function () {
  var self = this;

  if (self._queue.length &#x3e; 0) {
    var task = self._queue[0];

    // don&#x27;t move onto the next task until this one is done
    self.once(task.event, function() {
      self._queue.shift();
      self._loadQueue();
    });

    task.action();
  }

  return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  if (self._queue.length &#x3e; 0) {
    var task = self._queue[0];

    // don&#x27;t move onto the next task until this one is done
    self.once(task.event, function() {
      self._queue.shift();
      self.<span class="apidocCodeKeywordSpan">_loadQueue</span>();
    });

    task.action();
  }

  return self;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.howler.Howl.prototype._refreshBuffer" id="apidoc.element.howler.Howl.prototype._refreshBuffer">
        function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>_refreshBuffer
        <span class="apidocSignatureSpan">(sound)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_refreshBuffer = function (sound) {
  var self = this;

  // Setup the buffer source for playback.
  sound._node.bufferSource = Howler.ctx.createBufferSource();
  sound._node.bufferSource.buffer = cache[self._src];

  // Connect to the correct node.
  if (sound._panner) {
    sound._node.bufferSource.connect(sound._panner);
  } else {
    sound._node.bufferSource.connect(sound._node);
  }

  // Setup looping and playback rate.
  sound._node.bufferSource.loop = sound._loop;
  if (sound._loop) {
    sound._node.bufferSource.loopStart = sound._start || 0;
    sound._node.bufferSource.loopEnd = sound._stop;
  }
  sound._node.bufferSource.playbackRate.value = sound._rate;

  return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      sound._loop = !!(sound._loop || self._sprite[sprite][2]);

      // Begin the actual playback.
      var node = sound._node;
      if (self._webAudio) {
        // Fire this when the sound is ready to play to begin Web Audio playback.
        var playWebAudio = function() {
self.<span class="apidocCodeKeywordSpan">_refreshBuffer</span>(sound);

// Setup the playback params.
var vol = (sound._muted || self._muted) ? 0 : sound._volume;
node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
sound._playStart = Howler.ctx.currentTime;

// Play the sound using the supported method.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.howler.Howl.prototype._soundById" id="apidoc.element.howler.Howl.prototype._soundById">
        function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>_soundById
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_soundById = function (id) {
  var self = this;

  // Loop through all sounds and find the one with this ID.
  for (var i=0; i&#x3c;self._sounds.length; i++) {
    if (id === self._sounds[i]._id) {
      return self._sounds[i];
    }
  }

  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
for (var i=0; i&#x3c;self._howls.length; i++) {
  if (!self._howls[i]._webAudio) {
    // Get all of the sounds in this Howl group.
    var ids = self._howls[i]._getSoundIds();

    // Loop through all sounds and change the volumes.
    for (var j=0; j&#x3c;ids.length; j++) {
      var sound = self._howls[i].<span class="apidocCodeKeywordSpan">_soundById</span>(ids[j]);

      if (sound &#x26;&#x26; sound._node) {
        sound._node.volume = sound._volume * vol;
      }
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.howler.Howl.prototype._stopFade" id="apidoc.element.howler.Howl.prototype._stopFade">
        function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>_stopFade
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_stopFade = function (id) {
  var self = this;
  var sound = self._soundById(id);

  if (sound &#x26;&#x26; sound._interval) {
    if (self._webAudio) {
      sound._node.gain.cancelScheduledValues(Howler.ctx.currentTime);
    }

    clearInterval(sound._interval);
    sound._interval = null;
    self._emit(&#x27;fade&#x27;, id);
  }

  return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (sound &#x26;&#x26; !sound._paused) {
// Reset the seek position.
sound._seek = self.seek(ids[i]);
sound._rateSeek = 0;
sound._paused = true;

// Stop currently running fades.
self.<span class="apidocCodeKeywordSpan">_stopFade</span>(ids[i]);

if (sound._node) {
  if (self._webAudio) {
    // make sure the sound has been created
    if (!sound._node.bufferSource) {
      return self;
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.howler.Howl.prototype.duration" id="apidoc.element.howler.Howl.prototype.duration">
        function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>duration
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">duration = function (id) {
  var self = this;
  var duration = self._duration;

  // If we pass an ID, get the sound and return the sprite length.
  var sound = self._soundById(id);
  if (sound) {
    duration = self._sprite[sound._sprite][1] / 1000;
  }

  return duration;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.howler.Howl.prototype.fade" id="apidoc.element.howler.Howl.prototype.fade">
        function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>fade
        <span class="apidocSignatureSpan">(from, to, len, id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fade = function (from, to, len, id) {
  var self = this;
  var diff = Math.abs(from - to);
  var dir = from &#x3e; to ? &#x27;out&#x27; : &#x27;in&#x27;;
  var steps = diff / 0.01;
  var stepLen = (steps &#x3e; 0) ? len / steps : len;

  // Since browsers clamp timeouts to 4ms, we need to clamp our steps to that too.
  if (stepLen &#x3c; 4) {
    steps = Math.ceil(steps / (4 / stepLen));
    stepLen = 4;
  }

  // If the sound hasn&#x27;t loaded, add it to the load queue to fade when capable.
  if (self._state !== &#x27;loaded&#x27;) {
    self._queue.push({
      event: &#x27;fade&#x27;,
      action: function() {
        self.fade(from, to, len, id);
      }
    });

    return self;
  }

  // Set the volume to the start position.
  self.volume(from, id);

  // Fade the volume of one or all sounds.
  var ids = self._getSoundIds(id);
  for (var i=0; i&#x3c;ids.length; i++) {
    // Get the sound.
    var sound = self._soundById(ids[i]);

    // Create a linear fade or fall back to timeouts with HTML5 Audio.
    if (sound) {
      // Stop the previous fade if no sprite is being used (otherwise, volume handles this).
      if (!id) {
        self._stopFade(ids[i]);
      }

      // If we are using Web Audio, let the native methods do the actual fade.
      if (self._webAudio &#x26;&#x26; !sound._muted) {
        var currentTime = Howler.ctx.currentTime;
        var end = currentTime + (len / 1000);
        sound._volume = from;
        sound._node.gain.setValueAtTime(from, currentTime);
        sound._node.gain.linearRampToValueAtTime(to, end);
      }

      var vol = from;
      sound._interval = setInterval(function(soundId, sound) {
        // Update the volume amount, but only if the volume should change.
        if (steps &#x3e; 0) {
          vol += (dir === &#x27;in&#x27; ? 0.01 : -0.01);
        }

        // Make sure the volume is in the right bounds.
        vol = Math.max(0, vol);
        vol = Math.min(1, vol);

        // Round to within 2 decimal points.
        vol = Math.round(vol * 100) / 100;

        // Change the volume.
        if (self._webAudio) {
          if (typeof id === &#x27;undefined&#x27;) {
            self._volume = vol;
          }

          sound._volume = vol;
        } else {
          self.volume(vol, soundId, true);
        }

        // When the fade is complete, stop it and fire event.
        if ((to &#x3c; from &#x26;&#x26; vol &#x3c;= to) || (to &#x3e; from &#x26;&#x26; vol &#x3e;= to)) {
          clearInterval(sound._interval);
          sound._interval = null;
          self.volume(to, soundId);
          self._emit(&#x27;fade&#x27;, soundId);
        }
      }.bind(self, ids[i], sound), stepLen);
    }
  }

  return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
sound.pause(id);
```

- The deprecated `fadeIn` and `fadeOut` methods have been removed in favor of the single `fade` method.

```javascript
// Fade in a sound.
sound.<span class="apidocCodeKeywordSpan">fade</span>(0, 1, 1000);

// Fade out the sound once the previous fade has ended.
sound.once(&#x27;fade&#x27;, function(){
  sound.fade(1, 0, 1000);
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.howler.Howl.prototype.init" id="apidoc.element.howler.Howl.prototype.init">
        function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>init
        <span class="apidocSignatureSpan">(o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function (o) {
  var self = this;

  // Setup user-defined default properties.
  self._orientation = o.orientation || [1, 0, 0];
  self._stereo = o.stereo || null;
  self._pos = o.pos || null;
  self._pannerAttr = {
    coneInnerAngle: typeof o.coneInnerAngle !== &#x27;undefined&#x27; ? o.coneInnerAngle : 360,
    coneOuterAngle: typeof o.coneOuterAngle !== &#x27;undefined&#x27; ? o.coneOuterAngle : 360,
    coneOuterGain: typeof o.coneOuterGain !== &#x27;undefined&#x27; ? o.coneOuterGain : 0,
    distanceModel: typeof o.distanceModel !== &#x27;undefined&#x27; ? o.distanceModel : &#x27;inverse&#x27;,
    maxDistance: typeof o.maxDistance !== &#x27;undefined&#x27; ? o.maxDistance : 10000,
    panningModel: typeof o.panningModel !== &#x27;undefined&#x27; ? o.panningModel : &#x27;HRTF&#x27;,
    refDistance: typeof o.refDistance !== &#x27;undefined&#x27; ? o.refDistance : 1,
    rolloffFactor: typeof o.rolloffFactor !== &#x27;undefined&#x27; ? o.rolloffFactor : 1
  };

  // Setup event listeners.
  self._onstereo = o.onstereo ? [{fn: o.onstereo}] : [];
  self._onpos = o.onpos ? [{fn: o.onpos}] : [];
  self._onorientation = o.onorientation ? [{fn: o.onorientation}] : [];

  // Complete initilization with howler.js core&#x27;s init function.
  return _super.call(this, o);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/***************************************************************************/

/**
 * Create the global controller. All contained methods and properties apply
 * to all sounds that are currently playing or will be in the future.
 */
var HowlerGlobal = function() {
  this.<span class="apidocCodeKeywordSpan">init</span>();
};
HowlerGlobal.prototype = {
  /**
   * Initialize the global Howler object.
   * @return {Howler}
   */
  init: function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.howler.Howl.prototype.load" id="apidoc.element.howler.Howl.prototype.load">
        function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>load
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function () {
  var self = this;
  var url = null;

  // If no audio is available, quit immediately.
  if (Howler.noAudio) {
    self._emit(&#x27;loaderror&#x27;, null, &#x27;No audio support.&#x27;);
    return;
  }

  // Make sure our source is in an array.
  if (typeof self._src === &#x27;string&#x27;) {
    self._src = [self._src];
  }

  // Loop through the sources and pick the first one that is compatible.
  for (var i=0; i&#x3c;self._src.length; i++) {
    var ext, str;

    if (self._format &#x26;&#x26; self._format[i]) {
      // If an extension was specified, use that instead.
      ext = self._format[i];
    } else {
      // Make sure the source is a string.
      str = self._src[i];
      if (typeof str !== &#x27;string&#x27;) {
        self._emit(&#x27;loaderror&#x27;, null, &#x27;Non-string found in selected audio sources - ignoring.&#x27;);
        continue;
      }

      // Extract the file extension from the URL or base64 data URI.
      ext = /^data:audio\/([^;,]+);/i.exec(str);
      if (!ext) {
        ext = /\.([^.]+)$/.exec(str.split(&#x27;?&#x27;, 1)[0]);
      }

      if (ext) {
        ext = ext[1].toLowerCase();
      }
    }

    // Log a warning if no extension was found.
    if (!ext) {
      console.warn(&#x27;No file extension was found. Consider using the &#x22;format&#x22; property or specify an extension.&#x27;);
    }

    // Check if this extension is available.
    if (ext &#x26;&#x26; Howler.codecs(ext)) {
      url = self._src[i];
      break;
    }
  }

  if (!url) {
    self._emit(&#x27;loaderror&#x27;, null, &#x27;No codec support for selected audio sources.&#x27;);
    return;
  }

  self._src = url;
  self._state = &#x27;loading&#x27;;

  // If the hosting page is HTTPS and the source isn&#x27;t,
  // drop down to HTML5 Audio to avoid Mixed Content errors.
  if (window.location.protocol === &#x27;https:&#x27; &#x26;&#x26; url.slice(0, 5) === &#x27;http:&#x27;) {
    self._html5 = true;
    self._webAudio = false;
  }

  // Create a new sound object and add it to the pool.
  new Sound(self);

  // Load and decode the audio data for playback.
  if (self._webAudio) {
    loadBuffer(self);
  }

  return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        self.play();
      }
    });
  }

  // Load the source file unless otherwise specified.
  if (self._preload) {
    self.<span class="apidocCodeKeywordSpan">load</span>();
  }

  return self;
},

/**
 * Load the audio file.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.howler.Howl.prototype.loop" id="apidoc.element.howler.Howl.prototype.loop">
        function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>loop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loop = function () {
  var self = this;
  var args = arguments;
  var loop, id, sound;

  // Determine the values for loop and id.
  if (args.length === 0) {
    // Return the grou&#x27;s loop value.
    return self._loop;
  } else if (args.length === 1) {
    if (typeof args[0] === &#x27;boolean&#x27;) {
      loop = args[0];
      self._loop = loop;
    } else {
      // Return this sound&#x27;s loop value.
      sound = self._soundById(parseInt(args[0], 10));
      return sound ? sound._loop : false;
    }
  } else if (args.length === 2) {
    loop = args[0];
    id = parseInt(args[1], 10);
  }

  // If no id is passed, get all ID&#x27;s to be looped.
  var ids = self._getSoundIds(id);
  for (var i=0; i&#x3c;ids.length; i++) {
    sound = self._soundById(ids[i]);

    if (sound) {
      sound._loop = loop;
      if (self._webAudio &#x26;&#x26; sound._node &#x26;&#x26; sound._node.bufferSource) {
        sound._node.bufferSource.loop = loop;
        if (loop) {
          sound._node.bufferSource.loopStart = sound._start || 0;
          sound._node.bufferSource.loopEnd = sound._stop;
        }
      }
    }
  }

  return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.howler.Howl.prototype.mute" id="apidoc.element.howler.Howl.prototype.mute">
        function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>mute
        <span class="apidocSignatureSpan">(muted, id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mute = function (muted, id) {
  var self = this;

  // If the sound hasn&#x27;t loaded, add it to the load queue to mute when capable.
  if (self._state !== &#x27;loaded&#x27;) {
    self._queue.push({
      event: &#x27;mute&#x27;,
      action: function() {
        self.mute(muted, id);
      }
    });

    return self;
  }

  // If applying mute/unmute to all sounds, update the group&#x27;s value.
  if (typeof id === &#x27;undefined&#x27;) {
    if (typeof muted === &#x27;boolean&#x27;) {
      self._muted = muted;
    } else {
      return self._muted;
    }
  }

  // If no id is passed, get all ID&#x27;s to be muted.
  var ids = self._getSoundIds(id);

  for (var i=0; i&#x3c;ids.length; i++) {
    // Get the sound.
    var sound = self._soundById(ids[i]);

    if (sound) {
      sound._muted = muted;

      if (self._webAudio &#x26;&#x26; sound._node) {
        sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler.ctx.currentTime);
      } else if (sound._node) {
        sound._node.muted = Howler._muted ? true : muted;
      }

      self._emit(&#x27;mute&#x27;, sound._id);
    }
  }

  return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
sound.seek(10);
```

- `mute` and `unmute` have been consolidated into `mute`.

```javascript
// Mute a sound (or all sounds).
sound.<span class="apidocCodeKeywordSpan">mute</span>(true);
Howler.mute(true);

// Unmute a sound (or all sounds).
sound.mute(false);
Howler.mute(false);
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.howler.Howl.prototype.off" id="apidoc.element.howler.Howl.prototype.off">
        function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>off
        <span class="apidocSignatureSpan">(event, fn, id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">off = function (event, fn, id) {
  var self = this;
  var events = self[&#x27;_on&#x27; + event];
  var i = 0;

  if (fn) {
    // Loop through event store and remove the passed function.
    for (i=0; i&#x3c;events.length; i++) {
      if (fn === events[i].fn &#x26;&#x26; id === events[i].id) {
        events.splice(i, 1);
        break;
      }
    }
  } else if (event) {
    // Clear out all events of this type.
    self[&#x27;_on&#x27; + event] = [];
  } else {
    // Clear out all events of every type.
    var keys = Object.keys(self);
    for (i=0; i&#x3c;keys.length; i++) {
      if ((keys[i].indexOf(&#x27;_on&#x27;) === 0) &#x26;&#x26; Array.isArray(self[keys[i]])) {
        self[keys[i]] = [];
      }
    }
  }

  return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- Audio on Chrome for Android no longer gets stuck after a period of inactivity.
- Crash in iOS &#x3c;9 webview.
- Bug in iOS that can cause audio distortion when opening/closing browser.
- Only setup AudioContext after first `Howl` is setup so that background audio on mobile devices behaves as expected.

## 1.1.29 (January 22, 2016)
- `ADDED` Error messages added onto each `loaderror` event (thanks Philip Silva).
- `FIXED` Various edge-case bugs by no longer comparing functions by string in `.<span class="apidocCodeKeywordSpan">off</span>()` (
thanks richard-livingston).
- `FIXED` Edge case where multiple overlapping instances of the same sound won&#x27;t all fire `end` (thanks richard-livingston).
- `FIXED` `end` event now fires correctly when changing the `rate` of a sound.

## 1.1.28 (October 22, 2015)
- `FIXED` Typo with iOS enabler that was preventing it from working.

## 1.1.27 (October 2, 2015)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.howler.Howl.prototype.on" id="apidoc.element.howler.Howl.prototype.on">
        function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>on
        <span class="apidocSignatureSpan">(event, fn, id, once)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function (event, fn, id, once) {
  var self = this;
  var events = self[&#x27;_on&#x27; + event];

  if (typeof fn === &#x27;function&#x27;) {
    events.push(once ? {id: id, fn: fn, once: once} : {id: id, fn: fn});
  }

  return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Clear listener after first call.
sound.once(&#x27;load&#x27;, function(){
  sound.play();
});

// Fires when the sound finishes playing.
sound.<span class="apidocCodeKeywordSpan">on</span>(&#x27;end&#x27;, function(){
  console.log(&#x27;Finished!&#x27;);
});
```

##### Control multiple sounds:
```javascript
var sound = new Howl({
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.howler.Howl.prototype.once" id="apidoc.element.howler.Howl.prototype.once">
        function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>once
        <span class="apidocSignatureSpan">(event, fn, id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">once = function (event, fn, id) {
  var self = this;

  // Setup the event listener.
  self.on(event, fn, id, 1);

  return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- The deprecated `fadeIn` and `fadeOut` methods have been removed in favor of the single `fade` method.

```javascript
// Fade in a sound.
sound.fade(0, 1, 1000);

// Fade out the sound once the previous fade has ended.
sound.<span class="apidocCodeKeywordSpan">once</span>(&#x27;fade&#x27;, function(){
  sound.fade(1, 0, 1000);
});
```

### New Features
- Lots of general code cleanup, simplification and reorganization.
- Howler.js is now modularized. The core represents the initial goal for howler.js with 100% compatibility across HTML5 Audio and
 Web Audio. The spatial plugin adds spatial and stereo support through Web Audio API.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.howler.Howl.prototype.orientation" id="apidoc.element.howler.Howl.prototype.orientation">
        function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>orientation
        <span class="apidocSignatureSpan">(x, y, z, id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">orientation = function (x, y, z, id) {
  var self = this;

  // Stop right here if not using Web Audio.
  if (!self._webAudio) {
    return self;
  }

  // If the sound hasn&#x27;t loaded, add it to the load queue to change orientation when capable.
  if (self._state !== &#x27;loaded&#x27;) {
    self._queue.push({
      event: &#x27;orientation&#x27;,
      action: function() {
        self.orientation(x, y, z, id);
      }
    });

    return self;
  }

  // Set the defaults for optional &#x27;y&#x27; &#x26; &#x27;z&#x27;.
  y = (typeof y !== &#x27;number&#x27;) ? self._orientation[1] : y;
  z = (typeof z !== &#x27;number&#x27;) ? self._orientation[2] : z;

  // Setup the group&#x27;s spatial orientation if no ID is passed.
  if (typeof id === &#x27;undefined&#x27;) {
    // Return the group&#x27;s spatial orientation if no parameters are passed.
    if (typeof x === &#x27;number&#x27;) {
      self._orientation = [x, y, z];
    } else {
      return self._orientation;
    }
  }

  // Change the spatial orientation of one or all sounds in group.
  var ids = self._getSoundIds(id);
  for (var i=0; i&#x3c;ids.length; i++) {
    // Get the sound.
    var sound = self._soundById(ids[i]);

    if (sound) {
      if (typeof x === &#x27;number&#x27;) {
        sound._orientation = [x, y, z];

        if (sound._node) {
          // Check if there is a panner setup and create a new one if not.
          if (!sound._panner) {
            // Make sure we have a position to setup the node with.
            if (!sound._pos) {
              sound._pos = self._pos || [0, 0, -0.5];
            }

            setupPanner(sound, &#x27;spatial&#x27;);
          }

          sound._panner.setOrientation(x, y, z);
        }

        self._emit(&#x27;orientation&#x27;, sound._id);
      } else {
        return sound._orientation;
      }
    }
  }

  return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// If the sound hasn&#x27;t loaded, add it to the load queue to change orientation when capable.
if (self._state !== &#x27;loaded&#x27;) {
  self._queue.push({
    event: &#x27;orientation&#x27;,
    action: function() {
      self.<span class="apidocCodeKeywordSpan">orientation</span>(x, y, z, id);
    }
  });

  return self;
}

// Set the defaults for optional &#x27;y&#x27; &#x26; &#x27;z&#x27;.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.howler.Howl.prototype.pannerAttr" id="apidoc.element.howler.Howl.prototype.pannerAttr">
        function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>pannerAttr
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pannerAttr = function () {
  var self = this;
  var args = arguments;
  var o, id, sound;

  // Stop right here if not using Web Audio.
  if (!self._webAudio) {
    return self;
  }

  // Determine the values based on arguments.
  if (args.length === 0) {
    // Return the group&#x27;s panner attribute values.
    return self._pannerAttr;
  } else if (args.length === 1) {
    if (typeof args[0] === &#x27;object&#x27;) {
      o = args[0];

      // Set the grou&#x27;s panner attribute values.
      if (typeof id === &#x27;undefined&#x27;) {
        self._pannerAttr = {
          coneInnerAngle: typeof o.coneInnerAngle !== &#x27;undefined&#x27; ? o.coneInnerAngle : self._coneInnerAngle,
          coneOuterAngle: typeof o.coneOuterAngle !== &#x27;undefined&#x27; ? o.coneOuterAngle : self._coneOuterAngle,
          coneOuterGain: typeof o.coneOuterGain !== &#x27;undefined&#x27; ? o.coneOuterGain : self._coneOuterGain,
          distanceModel: typeof o.distanceModel !== &#x27;undefined&#x27; ? o.distanceModel : self._distanceModel,
          maxDistance: typeof o.maxDistance !== &#x27;undefined&#x27; ? o.maxDistance : self._maxDistance,
          panningModel: typeof o.panningModel !== &#x27;undefined&#x27; ? o.panningModel : self._panningModel,
          refDistance: typeof o.refDistance !== &#x27;undefined&#x27; ? o.refDistance : self._refDistance,
          rolloffFactor: typeof o.rolloffFactor !== &#x27;undefined&#x27; ? o.rolloffFactor : self._rolloffFactor
        };
      }
    } else {
      // Return this sound&#x27;s panner attribute values.
      sound = self._soundById(parseInt(args[0], 10));
      return sound ? sound._pannerAttr : self._pannerAttr;
    }
  } else if (args.length === 2) {
    o = args[0];
    id = parseInt(args[1], 10);
  }

  // Update the values of the specified sounds.
  var ids = self._getSoundIds(id);
  for (var i=0; i&#x3c;ids.length; i++) {
    sound = self._soundById(ids[i]);

    if (sound) {
      // Merge the new values into the sound.
      var pa = sound._pannerAttr;
      pa = {
        coneInnerAngle: typeof o.coneInnerAngle !== &#x27;undefined&#x27; ? o.coneInnerAngle : pa.coneInnerAngle,
        coneOuterAngle: typeof o.coneOuterAngle !== &#x27;undefined&#x27; ? o.coneOuterAngle : pa.coneOuterAngle,
        coneOuterGain: typeof o.coneOuterGain !== &#x27;undefined&#x27; ? o.coneOuterGain : pa.coneOuterGain,
        distanceModel: typeof o.distanceModel !== &#x27;undefined&#x27; ? o.distanceModel : pa.distanceModel,
        maxDistance: typeof o.maxDistance !== &#x27;undefined&#x27; ? o.maxDistance : pa.maxDistance,
        panningModel: typeof o.panningModel !== &#x27;undefined&#x27; ? o.panningModel : pa.panningModel,
        refDistance: typeof o.refDistance !== &#x27;undefined&#x27; ? o.refDistance : pa.refDistance,
        rolloffFactor: typeof o.rolloffFactor !== &#x27;undefined&#x27; ? o.rolloffFactor : pa.rolloffFactor
      };

      // Update the panner values or create a new panner if none exists.
      var panner = sound._panner;
      if (panner) {
        panner.coneInnerAngle = pa.coneInnerAngle;
        panner.coneOuterAngle = pa.coneOuterAngle;
        panner.coneOuterGain = pa.coneOuterGain;
        panner.distanceModel = pa.distanceModel;
        panner.maxDistance = pa.maxDistance;
        panner.panningModel = pa.panningModel;
        panner.refDistance = pa.refDistance;
        panner.rolloffFactor = pa.rolloffFactor;
      } else {
        // Make sure we have a position to setup the node with.
        if (!sound._pos) {
          sound._pos = self._pos || [0, 0, -0.5];
        }

        // Create a new panner node.
        setupPanner(sound, &#x27;spatial&#x27;);
      }
    }
  }

  return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.howler.Howl.prototype.pause" id="apidoc.element.howler.Howl.prototype.pause">
        function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>pause
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pause = function (id) {
  var self = this;

  // If the sound hasn&#x27;t loaded, add it to the load queue to pause when capable.
  if (self._state !== &#x27;loaded&#x27;) {
    self._queue.push({
      event: &#x27;pause&#x27;,
      action: function() {
        self.pause(id);
      }
    });

    return self;
  }

  // If no id is passed, get all ID&#x27;s to be paused.
  var ids = self._getSoundIds(id);

  for (var i=0; i&#x3c;ids.length; i++) {
    // Clear the end timer.
    self._clearTimer(ids[i]);

    // Get the sound.
    var sound = self._soundById(ids[i]);

    if (sound &#x26;&#x26; !sound._paused) {
      // Reset the seek position.
      sound._seek = self.seek(ids[i]);
      sound._rateSeek = 0;
      sound._paused = true;

      // Stop currently running fades.
      self._stopFade(ids[i]);

      if (sound._node) {
        if (self._webAudio) {
          // make sure the sound has been created
          if (!sound._node.bufferSource) {
            return self;
          }

          if (typeof sound._node.bufferSource.stop === &#x27;undefined&#x27;) {
            sound._node.bufferSource.noteOff(0);
          } else {
            sound._node.bufferSource.stop(0);
          }

          // Clean up the buffer source.
          self._cleanBuffer(sound._node);
        } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
          sound._node.pause();
        }
      }
    }

    // Fire the pause event, unless `true` is passed as the 2nd argument.
    if (!arguments[1]) {
      self._emit(&#x27;pause&#x27;, sound ? sound._id : null);
    }
  }

  return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- The `play` method no longer takes a callback and immediately returns the playback sound id (this means you can no longer chain
 onto the `play` method, but all others work the same).

```javascript
// Get sound id for a specific playback.
var id = sound.play();

// Pause this playback.
sound.<span class="apidocCodeKeywordSpan">pause</span>(id);
```

- The deprecated `fadeIn` and `fadeOut` methods have been removed in favor of the single `fade` method.

```javascript
// Fade in a sound.
sound.fade(0, 1, 1000);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.howler.Howl.prototype.play" id="apidoc.element.howler.Howl.prototype.play">
        function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>play
        <span class="apidocSignatureSpan">(sprite, internal)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">play = function (sprite, internal) {
  var self = this;
  var id = null;

  // Determine if a sprite, sound id or nothing was passed
  if (typeof sprite === &#x27;number&#x27;) {
    id = sprite;
    sprite = null;
  } else if (typeof sprite === &#x27;string&#x27; &#x26;&#x26; self._state === &#x27;loaded&#x27; &#x26;&#x26; !self._sprite[sprite]) {
    // If the passed sprite doesn&#x27;t exist, do nothing.
    return null;
  } else if (typeof sprite === &#x27;undefined&#x27;) {
    // Use the default sound sprite (plays the full audio length).
    sprite = &#x27;__default&#x27;;

    // Check if there is a single paused sound that isn&#x27;t ended.
    // If there is, play that sound. If not, continue as usual.
    var num = 0;
    for (var i=0; i&#x3c;self._sounds.length; i++) {
      if (self._sounds[i]._paused &#x26;&#x26; !self._sounds[i]._ended) {
        num++;
        id = self._sounds[i]._id;
      }
    }

    if (num === 1) {
      sprite = null;
    } else {
      id = null;
    }
  }

  // Get the selected node, or get one from the pool.
  var sound = id ? self._soundById(id) : self._inactiveSound();

  // If the sound doesn&#x27;t exist, do nothing.
  if (!sound) {
    return null;
  }

  // Select the sprite definition.
  if (id &#x26;&#x26; !sprite) {
    sprite = sound._sprite || &#x27;__default&#x27;;
  }

  // If we have no sprite and the sound hasn&#x27;t loaded, we must wait
  // for the sound to load to get our audio&#x27;s duration.
  if (self._state !== &#x27;loaded&#x27; &#x26;&#x26; !self._sprite[sprite]) {
    self._queue.push({
      event: &#x27;play&#x27;,
      action: function() {
        self.play(self._soundById(sound._id) ? sound._id : undefined);
      }
    });

    return sound._id;
  }

  // Don&#x27;t play the sound if an id was passed and it is already playing.
  if (id &#x26;&#x26; !sound._paused) {
    // Trigger the play event, in order to keep iterating through queue.
    if (!internal) {
      setTimeout(function() {
        self._emit(&#x27;play&#x27;, sound._id);
      }, 0);
    }

    return sound._id;
  }

  // Make sure the AudioContext isn&#x27;t suspended, and resume it if it is.
  if (self._webAudio) {
    Howler._autoResume();
  }

  // Determine how long to play for and where to start playing.
  var seek = Math.max(0, sound._seek &#x3e; 0 ? sound._seek : self._sprite[sprite][0] / 1000);
  var duration = Math.max(0, ((self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000) - seek);
  var timeout = (duration * 1000) / Math.abs(sound._rate);

  // Update the parameters of the sound
  sound._paused = false;
  sound._ended = false;
  sound._sprite = sprite;
  sound._seek = seek;
  sound._start = self._sprite[sprite][0] / 1000;
  sound._stop = (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000;
  sound._loop = !!(sound._loop || self._sprite[sprite][2]);

  // Begin the actual playback.
  var node = sound._node;
  if (self._webAudio) {
    // Fire this when the sound is ready to play to begin Web Audio playback.
    var playWebAudio = function() {
      self._refreshBuffer(sound);

      // Setup the playback params.
      var vol = (sound._muted || self._muted) ? 0 : sound._volume;
      node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
      sound._playStart = Howler.ctx.currentTime;

      // Play the sound using the supported method.
      if (typeof node.bufferSource.start === &#x27;undefined&#x27;) {
        sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);
      } else {
        sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);
      }

      // Start a new timer if none is present.
      if (timeout !== Infinity) {
        self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
      }

      if (!internal) {
        setTimeout(function() {
          self._emit(&#x27;play&#x27;, sound._id);
        }, 0);
      }
    };

    var isRunning = (Howler.state === &#x27;running&#x27;);
    if (self._state === &#x27;loaded&#x27; &#x26;&#x26; isRunning) {
      playWebAudio();
    } else {
      // Wait for the audio to load and then begin playback.
      var event = !isRunning &#x26;&#x26; self._state === &#x27;loaded&#x27; ? &#x27;resume&#x27; : &#x27;load&#x27;;
      self.once(event, playWebAudio, isRunn ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Howler.mute(false);
```

- The `play` method no longer takes a callback and immediately returns the playback sound id (this means you can no longer chain
 onto the `play` method, but all others work the same).

```javascript
// Get sound id for a specific playback.
var id = sound.<span class="apidocCodeKeywordSpan">play</span>();

// Pause this playback.
sound.pause(id);
```

- The deprecated `fadeIn` and `fadeOut` methods have been removed in favor of the single `fade` method.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.howler.Howl.prototype.playing" id="apidoc.element.howler.Howl.prototype.playing">
        function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>playing
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">playing = function (id) {
  var self = this;

  // Check the passed sound ID (if any).
  if (typeof id === &#x27;number&#x27;) {
    var sound = self._soundById(id);
    return sound ? !sound._paused : false;
  }

  // Otherwise, loop through all sounds and check if any are playing.
  for (var i=0; i&#x3c;self._sounds.length; i++) {
    if (!self._sounds[i]._paused) {
      return true;
    }
  }

  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

      // Get the sound.
      var sound = self._soundById(id);

      if (sound) {
        if (typeof seek === &#x27;number&#x27; &#x26;&#x26; seek &#x3e;= 0) {
// Pause the sound and update position for restarting playback.
var playing = self.<span class="apidocCodeKeywordSpan">playing</span>(id);
if (playing) {
  self.pause(id, true);
}

// Move the position of the track and cancel timer.
sound._seek = seek;
sound._ended = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.howler.Howl.prototype.pos" id="apidoc.element.howler.Howl.prototype.pos">
        function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>pos
        <span class="apidocSignatureSpan">(x, y, z, id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pos = function (x, y, z, id) {
  var self = this;

  // Stop right here if not using Web Audio.
  if (!self._webAudio) {
    return self;
  }

  // If the sound hasn&#x27;t loaded, add it to the load queue to change position when capable.
  if (self._state !== &#x27;loaded&#x27;) {
    self._queue.push({
      event: &#x27;pos&#x27;,
      action: function() {
        self.pos(x, y, z, id);
      }
    });

    return self;
  }

  // Set the defaults for optional &#x27;y&#x27; &#x26; &#x27;z&#x27;.
  y = (typeof y !== &#x27;number&#x27;) ? 0 : y;
  z = (typeof z !== &#x27;number&#x27;) ? -0.5 : z;

  // Setup the group&#x27;s spatial position if no ID is passed.
  if (typeof id === &#x27;undefined&#x27;) {
    // Return the group&#x27;s spatial position if no parameters are passed.
    if (typeof x === &#x27;number&#x27;) {
      self._pos = [x, y, z];
    } else {
      return self._pos;
    }
  }

  // Change the spatial position of one or all sounds in group.
  var ids = self._getSoundIds(id);
  for (var i=0; i&#x3c;ids.length; i++) {
    // Get the sound.
    var sound = self._soundById(ids[i]);

    if (sound) {
      if (typeof x === &#x27;number&#x27;) {
        sound._pos = [x, y, z];

        if (sound._node) {
          // Check if there is a panner setup and create a new one if not.
          if (!sound._panner || sound._panner.pan) {
            setupPanner(sound, &#x27;spatial&#x27;);
          }

          sound._panner.setPosition(x, y, z);
        }

        self._emit(&#x27;pos&#x27;, sound._id);
      } else {
        return sound._pos;
      }
    }
  }

  return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// If the sound hasn&#x27;t loaded, add it to the load queue to change position when capable.
if (self._state !== &#x27;loaded&#x27;) {
  self._queue.push({
    event: &#x27;pos&#x27;,
    action: function() {
      self.<span class="apidocCodeKeywordSpan">pos</span>(x, y, z, id);
    }
  });

  return self;
}

// Set the defaults for optional &#x27;y&#x27; &#x26; &#x27;z&#x27;.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.howler.Howl.prototype.rate" id="apidoc.element.howler.Howl.prototype.rate">
        function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>rate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rate = function () {
  var self = this;
  var args = arguments;
  var rate, id;

  // Determine the values based on arguments.
  if (args.length === 0) {
    // We will simply return the current rate of the first node.
    id = self._sounds[0]._id;
  } else if (args.length === 1) {
    // First check if this is an ID, and if not, assume it is a new rate value.
    var ids = self._getSoundIds();
    var index = ids.indexOf(args[0]);
    if (index &#x3e;= 0) {
      id = parseInt(args[0], 10);
    } else {
      rate = parseFloat(args[0]);
    }
  } else if (args.length === 2) {
    rate = parseFloat(args[0]);
    id = parseInt(args[1], 10);
  }

  // Update the playback rate or return the current value.
  var sound;
  if (typeof rate === &#x27;number&#x27;) {
    // If the sound hasn&#x27;t loaded, add it to the load queue to change playback rate when capable.
    if (self._state !== &#x27;loaded&#x27;) {
      self._queue.push({
        event: &#x27;rate&#x27;,
        action: function() {
          self.rate.apply(self, args);
        }
      });

      return self;
    }

    // Set the group rate.
    if (typeof id === &#x27;undefined&#x27;) {
      self._rate = rate;
    }

    // Update one or all volumes.
    id = self._getSoundIds(id);
    for (var i=0; i&#x3c;id.length; i++) {
      // Get the sound.
      sound = self._soundById(id[i]);

      if (sound) {
        // Keep track of our position when the rate changed and update the playback
        // start position so we can properly adjust the seek position for time elapsed.
        sound._rateSeek = self.seek(id[i]);
        sound._playStart = self._webAudio ? Howler.ctx.currentTime : sound._playStart;
        sound._rate = rate;

        // Change the playback rate.
        if (self._webAudio &#x26;&#x26; sound._node &#x26;&#x26; sound._node.bufferSource) {
          sound._node.bufferSource.playbackRate.value = rate;
        } else if (sound._node) {
          sound._node.playbackRate = rate;
        }

        // Reset the timers.
        var seek = self.seek(id[i]);
        var duration = ((self._sprite[sound._sprite][0] + self._sprite[sound._sprite][1]) / 1000) - seek;
        var timeout = (duration * 1000) / Math.abs(sound._rate);

        // Start a new end timer if sound is already playing.
        if (self._endTimers[id[i]] || !sound._paused) {
          self._clearTimer(id[i]);
          self._endTimers[id[i]] = setTimeout(self._ended.bind(self, sound), timeout);
        }

        self._emit(&#x27;rate&#x27;, sound._id);
      }
    }
  } else {
    sound = self._soundById(id);
    return sound ? sound._rate : self._rate;
  }

  return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Play returns a uniqe Sound ID that can be passed
// into any method on Howl to control that specific sound.
var id1 = sound.play();
var id2 = sound.play();

// Fade out the first sound and speed up the second.
sound.fade(1, 0, 1000, id1);
sound.<span class="apidocCodeKeywordSpan">rate</span>(1.5, id2);
```

More in-depth examples (with accompanying live demos) can be found in the [examples directory](https://github.com/goldfire/howler
.js/tree/master/examples).


## Core
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.howler.Howl.prototype.seek" id="apidoc.element.howler.Howl.prototype.seek">
        function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>seek
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">seek = function () {
  var self = this;
  var args = arguments;
  var seek, id;

  // Determine the values based on arguments.
  if (args.length === 0) {
    // We will simply return the current position of the first node.
    id = self._sounds[0]._id;
  } else if (args.length === 1) {
    // First check if this is an ID, and if not, assume it is a new seek position.
    var ids = self._getSoundIds();
    var index = ids.indexOf(args[0]);
    if (index &#x3e;= 0) {
      id = parseInt(args[0], 10);
    } else {
      id = self._sounds[0]._id;
      seek = parseFloat(args[0]);
    }
  } else if (args.length === 2) {
    seek = parseFloat(args[0]);
    id = parseInt(args[1], 10);
  }

  // If there is no ID, bail out.
  if (typeof id === &#x27;undefined&#x27;) {
    return self;
  }

  // If the sound hasn&#x27;t loaded, add it to the load queue to seek when capable.
  if (self._state !== &#x27;loaded&#x27;) {
    self._queue.push({
      event: &#x27;seek&#x27;,
      action: function() {
        self.seek.apply(self, args);
      }
    });

    return self;
  }

  // Get the sound.
  var sound = self._soundById(id);

  if (sound) {
    if (typeof seek === &#x27;number&#x27; &#x26;&#x26; seek &#x3e;= 0) {
      // Pause the sound and update position for restarting playback.
      var playing = self.playing(id);
      if (playing) {
        self.pause(id, true);
      }

      // Move the position of the track and cancel timer.
      sound._seek = seek;
      sound._ended = false;
      self._clearTimer(id);

      // Restart the playback if the sound was playing.
      if (playing) {
        self.play(id, true);
      }

      // Update the seek position for HTML5 Audio.
      if (!self._webAudio &#x26;&#x26; sound._node) {
        sound._node.currentTime = seek;
      }

      self._emit(&#x27;seek&#x27;, id);
    } else {
      if (self._webAudio) {
        var realTime = self.playing(id) ? Howler.ctx.currentTime - sound._playStart : 0;
        var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;
        return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));
      } else {
        return sound._node.currentTime;
      }
    }
  }

  return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### Breaking Changes
- The `buffer` option is now named `html5`. Use this to force HTML5 Audio usage.
- The `urls` option is now named `src` to specify the audio file(s) to play.
- The `pos` method has been renamed to `seek`.

```javascript
// Change the seek position of a sound (in seconds).
sound.<span class="apidocCodeKeywordSpan">seek</span>(10);
```

- `mute` and `unmute` have been consolidated into `mute`.

```javascript
// Mute a sound (or all sounds).
sound.mute(true);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.howler.Howl.prototype.state" id="apidoc.element.howler.Howl.prototype.state">
        function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>state
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">state = function () {
  return this._state;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.howler.Howl.prototype.stereo" id="apidoc.element.howler.Howl.prototype.stereo">
        function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>stereo
        <span class="apidocSignatureSpan">(pan, id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stereo = function (pan, id) {
  var self = this;

  // Stop right here if not using Web Audio.
  if (!self._webAudio) {
    return self;
  }

  // If the sound hasn&#x27;t loaded, add it to the load queue to change stereo pan when capable.
  if (self._state !== &#x27;loaded&#x27;) {
    self._queue.push({
      event: &#x27;stereo&#x27;,
      action: function() {
        self.stereo(pan, id);
      }
    });

    return self;
  }

  // Check for PannerStereoNode support and fallback to PannerNode if it doesn&#x27;t exist.
  var pannerType = (typeof Howler.ctx.createStereoPanner === &#x27;undefined&#x27;) ? &#x27;spatial&#x27; : &#x27;stereo&#x27;;

  // Setup the group&#x27;s stereo panning if no ID is passed.
  if (typeof id === &#x27;undefined&#x27;) {
    // Return the group&#x27;s stereo panning if no parameters are passed.
    if (typeof pan === &#x27;number&#x27;) {
      self._stereo = pan;
      self._pos = [pan, 0, 0];
    } else {
      return self._stereo;
    }
  }

  // Change the streo panning of one or all sounds in group.
  var ids = self._getSoundIds(id);
  for (var i=0; i&#x3c;ids.length; i++) {
    // Get the sound.
    var sound = self._soundById(ids[i]);

    if (sound) {
      if (typeof pan === &#x27;number&#x27;) {
        sound._stereo = pan;
        sound._pos = [pan, 0, 0];

        if (sound._node) {
          // If we are falling back, make sure the panningModel is equalpower.
          sound._pannerAttr.panningModel = &#x27;equalpower&#x27;;

          // Check if there is a panner setup and create a new one if not.
          if (!sound._panner || !sound._panner.pan) {
            setupPanner(sound, pannerType);
          }

          if (pannerType === &#x27;spatial&#x27;) {
            sound._panner.setPosition(pan, 0, 0);
          } else {
            sound._panner.pan.value = pan;
          }
        }

        self._emit(&#x27;stereo&#x27;, sound._id);
      } else {
        return sound._stereo;
      }
    }
  }

  return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // Stop right here if not using Web Audio.
  if (!self.ctx || !self.ctx.listener) {
    return self;
  }

  // Loop through all Howls and update their stereo panning.
  for (var i=self._howls.length-1; i&#x3e;=0; i--) {
    self._howls[i].<span class="apidocCodeKeywordSpan">stereo</span>(pan);
  }

  return self;
};

/**
 * Get/set the position of the listener in 3D cartesian space. Sounds using
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.howler.Howl.prototype.stop" id="apidoc.element.howler.Howl.prototype.stop">
        function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>stop
        <span class="apidocSignatureSpan">(id, internal)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stop = function (id, internal) {
  var self = this;

  // If the sound hasn&#x27;t loaded, add it to the load queue to stop when capable.
  if (self._state !== &#x27;loaded&#x27;) {
    self._queue.push({
      event: &#x27;stop&#x27;,
      action: function() {
        self.stop(id);
      }
    });

    return self;
  }

  // If no id is passed, get all ID&#x27;s to be stopped.
  var ids = self._getSoundIds(id);

  for (var i=0; i&#x3c;ids.length; i++) {
    // Clear the end timer.
    self._clearTimer(ids[i]);

    // Get the sound.
    var sound = self._soundById(ids[i]);

    if (sound) {
      // Reset the seek position.
      sound._seek = sound._start || 0;
      sound._rateSeek = 0;
      sound._paused = true;
      sound._ended = true;

      // Stop currently running fades.
      self._stopFade(ids[i]);

      if (sound._node) {
        if (self._webAudio) {
          // make sure the sound has been created
          if (!sound._node.bufferSource) {
            if (!internal) {
              self._emit(&#x27;stop&#x27;, sound._id);
            }

            return self;
          }

          if (typeof sound._node.bufferSource.stop === &#x27;undefined&#x27;) {
            sound._node.bufferSource.noteOff(0);
          } else {
            sound._node.bufferSource.stop(0);
          }

          // Clean up the buffer source.
          self._cleanBuffer(sound._node);
        } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
          sound._node.currentTime = sound._start || 0;
          sound._node.pause();
        }
      }
    }

    if (sound &#x26;&#x26; !internal) {
      self._emit(&#x27;stop&#x27;, sound._id);
    }
  }

  return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (!sound._node.bufferSource) {
    return self;
  }

  if (typeof sound._node.bufferSource.stop === &#x27;undefined&#x27;) {
    sound._node.bufferSource.noteOff(0);
  } else {
    sound._node.bufferSource.<span class="apidocCodeKeywordSpan">stop</span>(0);
  }

  // Clean up the buffer source.
  self._cleanBuffer(sound._node);
} else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
  sound._node.pause();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.howler.Howl.prototype.unload" id="apidoc.element.howler.Howl.prototype.unload">
        function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>unload
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unload = function () {
  var self = this;

  // Stop playing any active sounds.
  var sounds = self._sounds;
  for (var i=0; i&#x3c;sounds.length; i++) {
    // Stop the sound if it is currently playing.
    if (!sounds[i]._paused) {
      self.stop(sounds[i]._id);
    }

    // Remove the source or disconnect.
    if (!self._webAudio) {
      // Set the source to 0-second silence to stop any downloading.
      sounds[i]._node.src = &#x27;data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA&#x27;;

      // Remove any event listeners.
      sounds[i]._node.removeEventListener(&#x27;error&#x27;, sounds[i]._errorFn, false);
      sounds[i]._node.removeEventListener(Howler._canPlayEvent, sounds[i]._loadFn, false);
    }

    // Empty out all of the nodes.
    delete sounds[i]._node;

    // Make sure all timers are cleared out.
    self._clearTimer(sounds[i]._id);

    // Remove the references in the global Howler object.
    var index = Howler._howls.indexOf(self);
    if (index &#x3e;= 0) {
      Howler._howls.splice(index, 1);
    }
  }

  // Delete this sound from the cache (if no other Howl is using it).
  var remCache = true;
  for (i=0; i&#x3c;Howler._howls.length; i++) {
    if (Howler._howls[i]._src === self._src) {
      remCache = false;
      break;
    }
  }

  if (cache &#x26;&#x26; remCache) {
    delete cache[self._src];
  }

  // Clear global errors.
  Howler.noAudio = false;

  // Clear out `self`.
  self._state = &#x27;unloaded&#x27;;
  self._sounds = [];
  self = null;

  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * Unload and destroy all currently loaded Howl objects.
     * @return {Howler}
     */
    unload: function() {
var self = this || Howler;

for (var i=self._howls.length-1; i&#x3e;=0; i--) {
  self._howls[i].<span class="apidocCodeKeywordSpan">unload</span>();
}

// Create a new AudioContext to make sure it is fully reset.
if (self.usingWebAudio &#x26;&#x26; self.ctx &#x26;&#x26; typeof self.ctx.close !== &#x27;undefined&#x27;) {
  self.ctx.close();
  self.ctx = null;
  setupAudioContext();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.howler.Howl.prototype.volume" id="apidoc.element.howler.Howl.prototype.volume">
        function <span class="apidocSignatureSpan">howler.Howl.prototype.</span>volume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">volume = function () {
  var self = this;
  var args = arguments;
  var vol, id;

  // Determine the values based on arguments.
  if (args.length === 0) {
    // Return the value of the groups&#x27; volume.
    return self._volume;
  } else if (args.length === 1 || args.length === 2 &#x26;&#x26; typeof args[1] === &#x27;undefined&#x27;) {
    // First check if this is an ID, and if not, assume it is a new volume.
    var ids = self._getSoundIds();
    var index = ids.indexOf(args[0]);
    if (index &#x3e;= 0) {
      id = parseInt(args[0], 10);
    } else {
      vol = parseFloat(args[0]);
    }
  } else if (args.length &#x3e;= 2) {
    vol = parseFloat(args[0]);
    id = parseInt(args[1], 10);
  }

  // Update the volume or return the current volume.
  var sound;
  if (typeof vol !== &#x27;undefined&#x27; &#x26;&#x26; vol &#x3e;= 0 &#x26;&#x26; vol &#x3c;= 1) {
    // If the sound hasn&#x27;t loaded, add it to the load queue to change volume when capable.
    if (self._state !== &#x27;loaded&#x27;) {
      self._queue.push({
        event: &#x27;volume&#x27;,
        action: function() {
          self.volume.apply(self, args);
        }
      });

      return self;
    }

    // Set the group volume.
    if (typeof id === &#x27;undefined&#x27;) {
      self._volume = vol;
    }

    // Update one or all volumes.
    id = self._getSoundIds(id);
    for (var i=0; i&#x3c;id.length; i++) {
      // Get the sound.
      sound = self._soundById(id[i]);

      if (sound) {
        sound._volume = vol;

        // Stop currently running fades.
        if (!args[2]) {
          self._stopFade(id[i]);
        }

        if (self._webAudio &#x26;&#x26; sound._node &#x26;&#x26; !sound._muted) {
          sound._node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
        } else if (sound._node &#x26;&#x26; !sound._muted) {
          sound._node.volume = vol * Howler.volume();
        }

        self._emit(&#x27;volume&#x27;, sound._id);
      }
    }
  } else {
    sound = id ? self._soundById(id) : self._sounds[0];
    return sound ? sound._volume : 0;
  }

  return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
self._clearTimer(sound._id);
        }
      } else {
        // Fire this when the sound is ready to play to begin HTML5 Audio playback.
        var playHtml5 = function() {
node.currentTime = seek;
node.muted = sound._muted || self._muted || Howler._muted || node.muted;
node.volume = sound._volume * Howler.<span class="apidocCodeKeywordSpan">volume</span>();
node.playbackRate = sound._rate;
node.play();

// Setup the new end timer.
if (timeout !== Infinity) {
  self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
}
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
